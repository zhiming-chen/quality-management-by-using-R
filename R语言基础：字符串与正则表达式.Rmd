---
title: "R语言基础：正则表达式(一)"
author: "陈志明"
date: '2024-09-28'
documentclass: article
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,warning = FALSE)
##library(tidyverse) # Wickham的数据整理的整套工具
##library(lubridate) # 日期和日期时间数据处理
pdf.options(height=10/2.54, width=10/2.54, family="GB1") # 注意：此设置要放在最后
```

```{r echo=FALSE ,fig.width = 9,fig.height=3.83,dpi=300,dev="png"}
source("../cover/cover.R")
gen_cover(main ="R语言基础\n数据分析",
          subtitle = "正则表达式(3)\n反向引用与优先级",
          label = "专注R语言原创分享",
          bg_fig = "../cover/p_bg.png",
          min_fig = "../cover/min_bg_2.png",
          logo ="../cover/p_logo2.png")  %>% 
  ggsave("final3.png",.,device = "png",width = 9,height = 3.83)
 
```


起个头，写点正则表达式的内容，准备用四篇文章把R语言中的正则表达式基础应用说完，说明白。

正则表达式底层的那些类似于引擎优化，有限状态机等非应用层面的内容，就不写了，还是集中在应用层面。

虽然我这文字加起来也没几个人会看得到，但还是想多说几句，任何东西，是的，任何东西，任何情况下，都不要相信什么几分钟速成，一文学会...的说辞，要搞一个事情，要不就扎扎实实搞，要不就别去碰，想着速成是不可能的。

当然，也不要想着看别人几篇文章，就能掌握，不行的，需要自己下场敲字，反复敲字，用起来。

今天写第一部分，基础概念及简单语法。

# 什么是正则表达式

## 背景介绍

其实很多时候，我们都在用正则表达式，比如：

-   在电脑硬盘上用`*.docx`,
    `*年度总结*.pptx`搜索文件，这里的通配符`*`就是正则表达式的概念；

这个方法很有用，但他的功能还是有限的。

试想下，日常工作生活休闲娱乐等各种场景中，几乎处处充满规则，这些规则的自动判断背后的逻辑，可能都涉及到正则表达式。

-   密码格式不符合要求的情况下，永远设置不了密码，如何自动判断密码格式是否正确呢？

-   电话号码输入错误，身份证输入错误，邮箱输入错误，这些错误提醒是怎样实现的呢？

-   停下来休息玩一会`斗地主`,各种出牌的规则是不是也涉及到正则表达式呢？

-   工作中的各类文本处理，网站数据爬取，特殊场景特殊条件的信息搜索等，也可以用正则表达式来处理

## 什么是`正则表达式`

**`正则表达式(regular expression)`**:

> 一种字符串匹配的模式（pattern）和或规则，可以用来`检查、检索、匹配`字符串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

这个其实很好理解，就是一串字符形成的表达式，能够匹配查找到其他字符。说的更白一点，就是一定规则、条件、标准下的归纳，总结，类似这样，比如用红灯代表停，绿灯代表行，也是一种广义的物化表达式。 不过多展开。

## 正则表达式示例

### 示例1：

以下这个`url` 是一个网址构成的字符串向量，从结构上看：

第一串数字`158023`代表球员ID，

两串数字之间的字母等字符代表球员名字，

最后一串字符代表版本号信息。



```{r}
url <- c("https://sofifa.com/player/158023/lionel-messi/220024/",
         "https://sofifa.com/player/188545/robert-lewandowski/220024/",
"https://sofifa.com/player/192985/kevin-de-bruyne/220024/",
"https://sofifa.com/player/20801/c-ronaldo-dos-santos-aveiro/220024/",
"https://sofifa.com/player/190871/neymar-da-silva-santos-jr/220024/",
"https://sofifa.com/player/231747/kylian-mbappe/220024/")
url
```


现在我们想要把球员`ID`提取出来，有没有方法一次性提取全部呢。

正则表达式能帮助我们高效搞定。

我们观察到的规律就是`https://sofifa.com/player/` 这一串字符后的一连串数字；

或者说这串字符之后第一个`/`之前的一连串数字；

或者说是网址字符串第一次出现的一组数字；

下面这行代码基于最后这个规则逻辑，实现了我们的要求。

(如果不知道代码的意义，也不要紧，看完这个系列，会觉得这个代码是非常简单的)


```{r}
ID <- stringr::str_extract(url, "([0-9]+)")
ID 
```


### 示例2：如何提取球员姓名？

基于名字在字符串中的显示规则，分别用正则表达式来实现；

-   数字后全部小写字母和`-`;

```{r}
name_player <- stringr::str_extract(url, '(?<=([0-9]/))([a-z-]+)') 
   
name_player 
 
```

这个看起来就有点复杂了...

-   数字之间的小写字母和`-`；

```{r}
name_player_2 <- stringr::str_extract(url, '(?<=([0-9]/))[a-z-]+(?=(/[0-9]))')

name_player_2 
```

这个看上去貌似更复杂。


本例中，数字后全部小写字母和`-`即能约束姓名部分匹配条件，所以后面增加的数字前的内容，属于额外的多余的信息

-   `/`之间包含小写字母和`-`的内容，格式为`小写字母`+`-`+`小写字母`...

```{r}
name_player_3  <- stringr::str_extract(url, '(?<=/)(([A-Za-z]+-)+[A-Za-z]+)(?=/)')

name_player_3 
```

-   小写字母和`-`的规则组合；

```{r}
name_player_4 <- stringr::str_extract(url, '([a-z]+-)+[a-z]+')
name_player_4 
```

这个例子稍显复杂，先从简单的正则表达式基础语法展开。



#  正则表达式语法

正则表达式由普通字符和特殊字符构成，和数学表达式一样，熟悉规则后，正则表达式就是一句话，只是这些语言是用上述字符构成的。

> `TIPS`在R语言中，正则表达式以字符串的形式存在，用`""`(双引号)或`''`(单引号)括起来。如上述例子中的`'(?<=/)(([a-z]+-)+[a-z]+)(?=/)'`,即为单引号括起来的字符串，
在函数语句中作为`pattern` 参数的正则表达式。

 

## 普通字符

普通字符包括:

没有**显式指定为元字符**的所有**可打印和不可打印字符**。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。

举例，下列字符串中，包含了小写字母，数字以及一些其他字符，未显示指定为元字符的情况下，他们都是普通字符。

```{r}
samples <- "https://sofifa.com/player/158023/Lionel-Messi/220024/     是一个网址，
网址中不包含^、&、@、!、?、*\\,、()、{} \\$等特殊字符,来个大集合OK? abc ABC * 123\t.!?\\()[]{}\n | 
+ [四十是四十十四是十四] + * neymar-da-silva-santos-jr"
```



```{r}
stringr::str_view(samples, "[aeiou]")
```


为方便后续内容统一展开，重点以`samples`字符串为例展开，定义一个函数`seeit`，减少重复输入量。

```{r}
seeit <- function(rx) stringr::str_view(samples, rx)
```

###  `[...]` 匹配`[]`中的全部字符，如：

```{r}
seeit("[aeiou]")
```

###  `[^...]` 匹配`[]`中字符之外的全部字符，如：

```{r}
seeit("[^aeiou]")
```

###  `[A-Z]` 表示一个区间，匹配所有大写字母；相似地：

###  `[a-z]` 表示所有小写字母；

###   `[0-9]` 表示所有数字；

```{r}
seeit('[0-9]')
```

```{r}
seeit('[A-Z]')
```

```{r}
seeit('[a-z]')
```

###   `.` 表示除换行符{\n}、{\\r}之外的任何**单个**字符，相等于
    \[\^\\n\\r\]。如果要匹配`.`自身，需要增加转义符`\`，或者用`fixed()`函数。

 
- 匹配任意字符
```{r}
seeit('.')
```

- 匹配`.` 本身

```{r}
seeit('\\.')
```

```{r}
seeit(stringr::fixed('.'))
```

###   `\s` 表示所有空格，即匹配所有空白符，包括换行；

###   `\S` 表示所有非空格，即匹配所有非空白符，不包括换行。

```{r}
seeit('\\s')
```

```{r}
seeit('\\S')
```

###   `\w` 代表字母、数字、下划线等word类字符。等价于 \[A-Za-z0-9\_\]?

###   `\W` 代表字母、数字、下划线之外的非word类字符，等价于
    \[\^A-Za-z0-9\_\]?

```{r}
seeit('\\w')
```

```{r}
seeit('\\W')
```

##  **特殊字符**

特殊字符指:

除了其本身的存在，在正则表达式中还有特殊含义的字符。

如前述例子中，`.`在`samples`中就是以其本身存在，但在正则表达式中，`.`代表换行符外的任何单个字符；

重要特殊字符包括：

###   `$` 表示输入字符串的结尾位置。 要匹配`$`字符本身，前面加`\\`

参考示例：

匹配本身

```{r}
seeit('\\$')
```

表示输入字符串的结尾位置

比较下列两者区别：

```{r}
seeit('[a-z]+r')
```

```{r}
seeit('[a-z]+r$')
```

前者匹配以r结尾的子字符串，后者考察的是samples这个整个字符串

```{r}
seeit('.+r$')
```

**思考：** 为何在空格处停住了没匹配？

因为`.`不匹配换行符`\n`

```{r}
fruit <- c("apple","banana","pear","pinapple")

stringr::str_view(fruit,'.+e$')
```

###    `^` 在方括号内使用：表示不接受该方括号表达式中的字符集合；

在方括号外使用：匹配输入字符串的开始位置；

要匹配 \^ 本身，前面加`\\`。

参考示例：

匹配本身

```{r}
seeit('\\^')
```

在方括号内使用：表示不接受该方括号表达式中的字符集合

在普通字符部分已介绍，不赘述。

在方括号外使用：匹配输入字符串的开始位置

```{r}
seeit('^h.+')
```

```{r}
fruit <- c("apple","banana","pear","pinapple")
stringr::str_view(fruit,'^p.+')
```

###    `()`    表示一个子表达式的开始和结束位置,子表达式可以获取供以后使用。同要匹配
    `()`本身，前面加`\\`。

参考示例：

匹配本身

```{r}
seeit('\\(\\)')
```

表示一个子表达式的开始和结束位置,子表达式可以获取供以后使用。

```{r}
seeit('(.)(.).\\1\\2')
```

```{r}
seeit('(.)(.)(.)\\1\\2\\2\\1\\3\\2\\1')
```

本例中涉及反向引用的语法规则，暂不展开，后续内容里会有专门章节阐述，

这里只简单介绍`()`作为特殊字符的使用场景和作用。

###    `*` 表示匹配前面的子表达式零次或多次，与{0，}等价。同要匹配  `*`本身，前面加`\\`。

参考示例：

匹配本身

```{r}
seeit('\\*')
```

匹配零次或多次前面的子表达式

比较下述两者的区别，了解`*`在正则表达式中的作用

```{r}
seeit('\\d')
```

```{r}
seeit('\\d*')
```

###   `+` 表示匹配前面的子表达式一次或多次， 与{1，}等价。要匹配`+`本身，前面加`\\`。

参考示例：

匹配本身

```{r}
seeit('\\+')
```

匹配一次或多次前面的子表达式

比较下述两者的区别，了解`+`在正则表达式中的作用

```{r}
seeit('\\d')
```

```{r}
seeit('\\d+')
```

用`str_view`函数来看一下效果

```{r}
stringr::str_view(samples,'\\d')
stringr::str_view(samples,'\\d+')
```

可以看出，不加`+`，匹配第一个数字，加上`+`，匹配第一组数字，亦即匹配一个或多个，直到没有即停止。

从英文字母及单词的维度看，就是匹配字母和匹配单词的区别；

灵活应用该特殊字符，可以帮助解决很多问题，如前述示例中提及的获取球员name的案例，将

英文字母和`-`作为一组字符串，后加上`+`,实现一组或多组结构，实现对全部球员姓名的抓取。

`name_player_4 <- stringr::str_extract(url, '([a-z]+-)+[a-z]+')`

我们同样可以用类似方法实现对`samples`中同类型字符串进行匹配

```{r}
seeit('([A-Za-z]+-)+[A-Za-z]+')
```

该示例中，正则表达式出现三次`+`,第一次和第三次出现在`[]`中括号后，指代匹配中括号内字符一次或多次；

第二次出现在`()`后，指代匹配`()`内字符一次或多次。

###    `?`
    表示匹配前面的子表达式零次或一次，或指明一个非贪婪限定符;与{0，1}等价。

要匹配 `?`本身，前面加`\\`。

参考示例：

匹配本身

```{r}
seeit('\\?')
```

匹配前面的子表达式零次或一次

研究一下下述两个表达式之间的区别

```{r}
seeit('[1-9][0-9]?')
```

```{r}
seeit('[1-9]?[0-9]')
```

指明一个非贪婪限定符

`贪婪`模式示例，会尽量多的匹配,比如下列函数，会把全部非符号字符的字符全部匹配出来；

```{r}
seeit('\\w+')
```

`非贪婪`模式示例，上例中，在`+`后加个`?`，即可实现非贪婪模式，即`?`起到指明一个非贪婪限定符的作用

```{r}
seeit('\\w+?')
```

关于贪婪模式，不做展开，后续内容里会有专门章节阐述，这里只简单介绍`?`作为特殊字符的使用场景和作用。

###   `.` 在普通字符中已介绍，不赘述。

###    `[]` 表示一个中括号表达式的开始及结束;要匹配 `[]`本身，前面加`\\`

参考示例

匹配本身

```{r}
seeit('\\[]')

seeit('\\[.+\\]')
```

**`思考`** :
为何`seeit('\\[]')`匹配到了内容，`seeit('\\{}')`匹配不到内容，且报错。

表达一个中括号表达式,表示匹配中括号内的任一字符串。

```{r}
seeit('[a-dB-Q]')
```

###    `\`表示转义符。用于将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。

要匹配本身，在前本身前面加`\\`,因为`\`在字符串中以`\\`的形式存在，所以匹配一个`\`本身的正则表达式

即须写成`\\\\`（这是R语言环境下的写法）。

转义符在正则表达式中用处颇多；重点用法和场合，后续会逐一涉及到.

参考示例：

匹配本身

```{r}
seeit('\\\\')
```

作为转义符

-   换行 `\n`,字母`n`作为普通字符，就表示其本身的意思

-   加上转义符 `\n`,即为换行的意思

```{r}
seeit('n')
```

```{r}
seeit('\\n')
```

实现向后引用,用于数字前，表示重复第几位字符串

```{r}
seeit('(.)\\1')


```

```{r}
seeit('(.)(.)\\2\\1')
```

###    `{}` 用于表示限定符，`{`  表示限定符开始，`}`表示限定符结束。要匹配他们本身，前面加`\\`；

关于限定符，后续内容里会有介绍；

参考的示例：

匹配4到6位的小写英文字母；

（用`{4,6}`
来表示4到6位这个限定要求，abc这串只有3位的英文字母字符串不会匹配出来）

```{r}
seeit('[a-z]{4,6}')
```

匹配`{}`本身；

```{r}
seeit('\\{\\}')
```

###   `|` 表示指明两项之间的一个选择；如`A|B`，匹配`A`或者`B`。要匹配 `|`
    本身，使用`\\|`；

参考的示例：

匹配大小写字母或数字：

```{r}
seeit('[a-zA-Z]|[0-9]')
```

匹配`|`本身或`$`本身或`}`本身

```{r}
seeit('\\||\\$|\\}')
```




##  **限定符**

共有6种限定符，用于指定正则表达式中给定的`组件`需要出现**多少次**才能满足匹配要求；或者说：

匹配出现了多少次的内容（字符串）；6种限定符分别是：

+ `*`，匹配零次或多次，

+ `+`，匹配一次或多次，

+ `?`，匹配零次或一次。

上述三种限定符，已在特殊字符中进行了介绍，这里不再赘述。

+ `{n}`,`n` 必须为非负整数，即大于等于0的整数，表示匹配确定的`n`次。

```{r}
seeit('[0-9]{4}')
```

+ `{n,}`, `n` 必须为非负整数，即大于等于0的整数，表示至少匹配`n`次。

```{r}
seeit('[0-9]{2,}')
```

+ `{m,n}`, `m`,`n` 必须为非负整数，即大于等于0的整数，`n`需大于等于`m`；

表示至少匹配`m`次,q且最多匹配`n`次。

```{r}
seeit('[0-9]{3,5}')
```

##  **定位符**

顾名思义，定位符指的是确定位置的字符。常用的定位符有：

+ `^`: 定位字符串开始位置

+ `$`: 定位字符串结束位置

这两个字符在特殊字符里已做介绍，不再赘述。

+ `\b`: 定位单词（words）的边界;

+ `\B`: 定位非单词的边界。

参考示例

```{r}
seeit('\\b')
```
```{r}
seeit('\\B')
```

比较下述两语句的区别，理解`\b`和`\B`的区别

```{r}
seeit('\\bsi')
seeit('\\Bsi')
```

**注意** 定位符与限定符不能一起使用。原因在于正常的行文语句表达中，紧靠换行或者单词边界的前面或

后面不应有一个以上的位置，因此不允许诸如^*之类的表达式。

（来源网站：https://www.runoob.com/regexp/regexp-syntax.html）

*这个结论待分析验证，如下语句，能正常运行，但确实没多大意义。存疑。*
```{r}
seeit('^*')
```
（接3月12日，继续进行）

##  **选择与反向引用**
 
用游戏的思维技能的思维来理解：

+ 普通字符，单一技能，自己只能是自己，就像普通士兵，  有些士兵穿上道具能变身其他兵种，具备特殊功能，比如`n`穿上道具`\`,就变成换行符（巫师）；

+ 特殊字符，就是右多种技能的巫师，定位符`^`,`$`天生具有固定敌人的功能，`+`,`*`,`?`等限定符天生具有群查群杀的功能，这些特殊巫师，需要穿上道具`\`,才能做回自己，成为普通士兵；

也就是说，字符就只有普通字符和特殊字符两类，限定符，定位符，选择与反向引用，非打印字符等都可以认为是`士兵的技能`，正则表达式就是灵活用士兵和巫师，把他们的技能排列组合最优化。

以此逻辑，`选择与反向引用`是两种强大的高阶技能，通常由几种巫师（特殊字符）参与

### **选择**

先看`选择`。选择这个功能可以类似于打包、编队处理，通过使用圆括号`()` 将所有选择项括起来，

实现分组捕获。`()`把每个分组里匹配的值保存起来，这些分组匹配值可通过数字 n 来查看；

(n 是一个数字，表示第 n 个捕获组的内容),通过这些数字即可实现反向引用。


 
 对比下述两种写法的区别

不用`()`对小写英文字母和`-`进行分组
```{r}
seeit('[a-z]+-+[a-z]+')
```
 
使用`()`对小写英文字母和`-`进行分组
```{r}
seeit('([a-z]+-)+[a-z]+')
```

第二种写法将小写字母组合与`-`作为一个整体，后面跟`+`，表示这个整体匹配一次或多次。

做个分析总结，第二种写法中，以普通字符身份存在的只有第二个`-`,其余字符都以特殊字符的身份出现，有些是单独施放魔法，有些是组合施放魔法；其中第一个和第三个`-`与小写字母`a`和`z`组合，用中括号`[]`括住表示全部小写字母,后跟`+`表示匹配一次或多次任意小写字母，这一次或多次小写字母与一个`-`（作为普通字符）被`()`括起来作为一个整体...

```{r}
stringr::str_extract_all(samples, '([A-Za-z]+\\/)([0-9]+\\/)')
```

圆括号`()`的“副作用”：`()`内的匹配内容会被缓存，如何消除此缓存呢。这里引出环视（look arounds）或者说零宽断言的概念。

###  环视（look arounds）：也有流行的说法：零宽断言，或者断言，叫什么名字不重要，知道其原理和作用，并灵活应用即可。

通俗的说，环视就是实现先全局环顾正则，再做进一步匹配处理。比如`每个成功的男人，背后都离不开那么几个女人`，要找出那么几个女人，得先确定那个成功的男人（深圳马和杭州马身后的女人不一样的，不能胡乱抓），本质上来看，还是解决了定位的问题。



 下列语句中，我们匹配一个或多个大小写字母后跟`/`的组合或者一个或多个数字后跟`/`的组合
```{r}
seeit('[A-Za-z]+\\/|[0-9]+\\/')
```

如果我只想要`/`前的字母或数字，不想要`/`,如何实现？

有人说直接不加`/`就行了，但是这样又把其他后面没跟`/`的字母和数字都匹配进来了，显然不符合要求。

要实现上述把`/`踢出去（豁免掉），就需要启动消除括号中的缓存的功能来满足该要求。


```{r}
seeit('[A-Za-z]+(?=\\/)|[0-9]+(?=\\/)')
```

上述语句实现了这个功能，其中`?=` 为非捕获元，可以看做`?`和`=`两个巫师组合后施放的一种`组合技`；

同类的非捕获元`组合技` 还有`?<=`、`?!`、`?<!`等；先来看看他们写入正则表达式的匹配结果：

匹配数字`0`前面的位置，但不占宽度 
```{r}
seeit('(?=0)')
 
```

匹配数字`0`前面位置之外的全部位置,但不占宽度
```{r}
 
seeit('(?!0)')
 
```

匹配数字`0`后面的位置，但不占宽度 
```{r}
 seeit('(?<=0)')
 
```

匹配数字`0`后面的位置之外的全部位置，但不占宽度 
```{r}
seeit('(?<!0)')
```


这四个语句结果显示：

+ 环视部分不占宽度，所以被称为零宽断言；



其具体用法，分别做介绍并示例说明。


+ `?=` : exp1(`?=`exp2)，匹配`exp2` 

前面的`exp1`,后面紧跟着exp2的exp1都将被匹配，如上例中，后面紧跟了`/`的字母们和数字们，都被匹配到了。

+ `?!` ：exp1(`?!`exp2)，`?=`的否定语义，表示匹配不在`exp2` 

前面的`exp1`,后面没有紧跟着exp2的exp1都将被匹配，如下例中，后面未紧跟`/`的字母们和数字们，都被匹配到了。

```{r}
seeit('[A-Za-z]+(?!\\/)|[0-9]+(?!\\/)')
```

匹配结果还是有点与预期不一致，比如`/`前面的`158023`并非全部未匹配，因为表达式的指示是`后面未紧跟``/`,对于`15802`这几个数字来讲，确实后面没有紧跟`/`,他们紧跟的是数字`3`,所以就匹配到了，同样的情形还发生在`player`等，要如何实现`?=`的绝对逆操作呢？

+ `?<=` ：(`?<=`exp2)exp1, 匹配`exp2`后的`exp1`，即紧跟在`exp2`后面的`exp1`将被匹配；

如下例，紧跟`/`后的字母或数字们都被匹配到了。

```{r}
seeit('(?<=\\/)[A-Za-z]+|(?<=\\/)[0-9]+')
```

+ `?<!` ：(`?<！`exp2)exp1, `?<=`的否定操作。匹配不在`exp2`后的`exp1`，即未紧跟在`exp2`后面的`exp1`将被匹配；

如下例，未紧随`/`之后的字母或数字们都被匹配到了。

```{r}
seeit('(?<!\\/)[A-Za-z]+|(?<!\\/)[0-9]+')
```

同样地，匹配结果与预期有点不一致，并非`?<=`的绝对逆操作。

上述结果显示：

 + 环视的匹配结果并不会纳入最终匹配数据结果；
 
 + 环视它匹配过得地方，下次还能用它继续匹配，如果不是环视，匹配过的地方，不能再匹配第二次。

另外，拓展一下四种环视表达之外的情形；

`?=` 和 `?!` 分别用于exp1(`?=`exp2)和exp1(`?！`exp2)，如果将exp1放在()后面会出现什么结果呢

```{r}
seeit('(?!0)[0-9]')
```

上例匹配了`0-9`中不包含`0`的全部数字；可以理解为先找数字`0`前面位置之外的全部位置,再把这些位置上（默认是位置后面的）0-9的数字匹配出来；

```{r}
seeit('(?!0)[0-9]+')
```

上例在`[0-9]`后加上`+`,要求匹配一次或多次，结果显示全部数字都匹配上了，是不是这个零宽断言失灵了呢，显然不是。它的工作原理是先通过`(?!0)`找到位置，再匹配这些位置后的数字，尽可能的匹配。（即所谓`贪婪模式`，后续会专题讲解）再用一个例子来阐述这个工作原理

```{r}
stringr::str_view(c('0023045067b00985c1098','a0230450b7','10230400b0'), '(?!0)[0-9]+')
```

这个例子中，三组数字+字母组合，用`(?!0)[0-9]+`正则表达式来匹配：

第一个组合，匹配到的第一个位置为数字`2`前面的位置，所以这位置后的全部数字全部匹配上，知道遇到数字`7`后面的`b`停止，`b`后面两个`0`没有匹配到位置，所以不理会，继续往后，碰到数字`9`...

第二个组合，第三个组合都是同样的道理。以此逻辑，下例子中，显然就只能匹配到数字`0`本身了
```{r}
seeit('(?=0)[0-9]')
```


看看这个例子：
```{r}
seeit('(?=0)[0-9]+')
```

显然，匹配到的自然就是数字`0`及后面的数字们了，可以理解为从`0`开始的数字组；

和`'(?<=0)[0-9]+'`表达式轻微区别，这个表达式匹配的是`0`(连续`0`的情况下，第二个`0`被忽略，因为第一个`0`后被生成了一个位置，匹配后面的数字，也会从这个位置开始)后面的数字组。

来看下区别

```{r}
seeit('(?<=0)([0-9])+')
```



如何匹配连续`0`后面的的字符串呢？？

`0`的位置找到后，后面的字符串表达式中开始若干位不是`0`即可

```{r}
seeit('(?<=0)((?!0)[0-9])+[0-9]*')
```

再看两个例子：
匹配`s`后面，不以`s`开头的小写字母字符串（字符串中可包含`s`）
```{r}
seeit('(?<=s)((?!s)[a-z])+[a-z]*')
```

匹配`s`后面，不以`s`开头的，且不包含`s`的小写字母字符串
```{r}
stringr::str_view('qasssses45ssasaw', '(?<=s)((?!s)[a-z])+')
```

这两个例子试图匹配字母`s`后面的小写字母或字母组合，这些组合的首字母不能是字母`s`。

首先，表达式通过`(?<=s)`环视找到字母s后面的位置，从这些位置开始往后找小写字母；

怎么找呢？

先按这个`(?!s)[a-z]`表达式的要求找，这个表达式前面已经讲过，匹配不是`s`的小写字母；

并且按`((?!s)[a-z])+`匹配一次或多次不是`s`的小写字母；

如果字符串中后续字符可以包含`s`,在表达式`((?!s)[a-z])+`后加`[a-z]*`即可；

不能是`[a-z]+`，因为这样的话匹配的字符串至少是两位， 那么只有一位的单个字母就匹配不到了。

以上，把环视、零宽断言、“瞻前顾后”等`技能`逐一做了说明，相关逻辑和运行原理也进行了熟悉掌握；最后以一个例子结束这部分

`mp3`字符串组合来源`bbc` learningenglish的一个mp3下载链接，现在要从这些字符串中找出包含数字、小写英文字母和`.`或`_`(英文字母 数字和标点符号(`.`或`_`)必须包含两种及以上),长度大于10的字符串组合。
```{r}
mp3<- c("http://downloads",".bbc.co.uk",
"learningenglish",
"features6min.220303",
"6min_english_kindness",
"235645780043")
```

```{r}
stringr::str_view(mp3, '[a-z0-9\\.\\-]{10,}')
```
用这个正则表达式进行匹配，没有数字和标点符号的也被匹配了，用本小节介绍的方法，对纯数字，纯字母和纯标点的字符串进行排除

```{r}
stringr::str_view(mp3, '(?!^[0-9]+$)(?!^[a-z]+$)(?!^[\\.\\-]+$)^[a-z0-9\\.\\_]{10,}')
```

如上正则表达式，能有效匹配到满足需求的字符串。
 
###  **反向引用**

先看几个例子：`rkling`是一个绕口令；
```{r}
rkling <- '一二三，三二一，一二三四五六七，七六五四三二一，七个姑娘来聚齐。七只花篮手中提，一齐来到果园里，摘的是槟子、橙子、桔子、柿子、李子、栗子、梨'
```

1. 我们用正则表达式来匹配我们感兴趣的地方，比如`一二三，三二一`

```{r}
stringr::str_view(rkling, '(一)(二)(三).\\3\\2\\1')
```

2. 我想匹配全部类似这种镜像对称文字

```{r}
stringr::str_view(rkling, '(.)(.)(.).\\3\\2\\1')
```

3. 我想把`一二三，三二一，一二三四五六七，七六五四三二一`都匹配上

```{r}
stringr::str_view(rkling, '(.)(.)(.).+\\3\\2\\1')
```
上述三个例子均用到了`反向引用`技能。

 

如前描述， `圆括号`内表达式匹配的内容，即各个捕获的子匹配，都会按照在正则表达式模式中从左到右的顺序进行存储，存储到一个临时缓冲区里，缓冲区编号从1开始，最多可存储99个捕获的子表达式。每个缓冲区都可以用`\\n`来访问，这里的`n`为一个表示缓冲区的一位或两位十进制数字。

基于这样的原理，`()`和`\\数字`组合起来，可以高效简洁的完成很多检索匹配任务。

来看几个关于英语歌词的例子
```{r}
song <- "I'm a big big girl, in a big big world,It's not a big big thing if you leave me."
rm(ttwister)
```

匹配连续的重复单词，也就是`big big`
```{r}
stringr::str_view(song, '\\b([A-Za-z]+\\s)\\1')
```
 
我想匹配`a big big X`这样的短语

```{r}
stringr::str_view(song, 'a\\s\\b([A-Za-z]+\\s)\\1\\b[A-Za-z]+')
```

当然匹配固定格式的成语也是手到擒来

匹配ABCB型成语
```{r}
idiom <- c("一动不动","人不犯我我不犯人","浑浑噩噩","半信半疑","自欺欺人","不了了之","人云亦云")
stringr::str_view(idiom, '(.)(.)(.)\\2')
```

匹配AABB型成语 

```{r}
stringr::str_view(idiom, '(.)\\1(.)\\2')
```

匹配ABAC型成语 

```{r}
stringr::str_view(idiom, '(.)(.)\\1(.)')
```

匹配ABBC型成语 

```{r}
stringr::str_view(idiom, '\\b(.)(.)\\2(.)')
```

匹配`人不犯我我不犯人`

```{r}
stringr::str_view(idiom, '(.)(.)(.)(.)\\4\\2\\3\\1')
```

##  **运算优先级**

和算术表达式一样，正则表达式也有顺序和优先级

优先级高的先计算，优先级相同的从左到右顺序计算；

优先级1：转义符`\\`优先级最高，这个好理解，先把字符的身份认清楚，是`普通士兵`还是带技能的`巫师`；

优先级2：圆括号`()`,`[]`,和算术运算类似，圆括号的优先级高；

优先级3：六种限定符：`+`,`*`,`?`,`{n}`,`{n,}`,`{m,n}`;

优先级4：定位符及其他各种字符：`^`,`$`,`\\b`,`\\B`, ...，表征位置和顺序的字符；

优先级5：`|`字符，或操作。

普通字符的优先级高于`|`，注意这个特性在某些场景下的应用，比如，我们想匹配`mood`或`food`,正则表达式不能这样写

```{r}
stringr::str_view('mood,food,understand', 'm|food')
```

这样写匹配到的是`m`和`food`；

这样写的结果则不一样：将`m|f`用`()`括起来，优先级提高，先找`m`和`f`，然后再找他们后面的`ood`,这样就实现了上述需求。

```{r}
stringr::str_view('mood,food,understand', '(m|f)ood')
```
同样的例子,观察三者的区别，

```{r}
stringr::str_view('bit,bet,bat,bot', 'bi|e|o|t')
stringr::str_view('bit,bet,bat,bot', 'b(i|e|o)t')
stringr::str_view('bit,bet,bat,bot', '\\bb.t')
```




##  **贪婪模式与匹配规则**

限定符解决了匹配数的问题，这里表征出两种模式，即贪婪模式和非贪婪模式；

把正则表达式的匹配理解为士兵或巫师施展技能，这个技能的效用范围通过限定符等字符表达式来确定；

`+`,`*`,`{n,}`可以理解为支持贪婪模式，他们作用的字符串会被尽可能的匹配；

`?`,`{m,n}`,`{n}`可以理解为支持非贪婪模式，他们作用的字符串会被按限定的规则进行匹配。

`+`,`*`后加`?`,则变成了非贪婪模式。

举例说明：

```{r}
ns <- c("101","10001","100010001","10001000")
```
匹配`1`及后面的一个或多个`0`
```{r}
stringr::str_view(ns, '10+')
```

```{r}
stringr::str_view(ns, '10+1')
```

```{r}
stringr::str_view(ns, '10*')
```

```{r}
stringr::str_view(ns, '10*?')
```

```{r}
stringr::str_view(ns, '10+?')
```

```{r}
stringr::str_view(ns, '10*1')
```

```{r}
stringr::str_view(ns, '10*?1')
```

```{r}
stringr::str_view(ns, '10?1')
```


